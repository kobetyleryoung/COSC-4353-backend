from __future__ import annotations
from typing import Protocol, Optional, Iterable
from datetime import datetime

from .events import Event, EventId
from .profiles import Profile, UserId
from .volunteering import Opportunity, OpportunityId, Match, MatchId, MatchRequest, MatchRequestId, VolunteerHistoryEntry, VolunteerHistoryEntryId
from .notifications import Notification, NotificationId
from .users import User

# this is where we define repository interfaces (techinally abstract base classes)
# i added these so we can swap out implementations more easily
# and to make it clear what operations are supported on each entity.
# NOTE: just for reference, this is the 'D' in SOLID principles (dependency inversion)

# this is the bridge betwee <-- service layer and data layer. Servie layer
# populates te domain models and passes them to the repo to save (also uses models, but
# not dataclasses, sqlalchemy models). repositories/ houses the actual db access code

#---- Repository Interfaces ----
class EventRepository(Protocol):
    def get(self, event_id: EventId) -> Optional[Event]: ...
    def add(self, event: Event) -> None: ...
    def save(self, event: Event) -> None: ...
    def list_upcoming(self, *, limit: int = 50, as_of: datetime | None = None) -> list[Event]: ...

class ProfileRepository(Protocol):
    def get(self, user_id: UserId) -> Optional[Profile]: ...
    def save(self, profile: Profile) -> None: ...

class OpportunityRepository(Protocol):
    def get(self, opp_id: OpportunityId) -> Optional[Opportunity]: ...
    def add(self, opp: Opportunity) -> None: ...
    def save(self, opp: Opportunity) -> None: ...
    def list_for_event(self, event_id: EventId) -> list[Opportunity]: ...

class MatchRepository(Protocol):
    def get(self, match_id: MatchId) -> Optional[Match]: ...
    def add(self, match: Match) -> None: ...
    def save(self, match: Match) -> None: ...
    def list_for_user(self, user_id: UserId, *, limit: int = 100) -> list[Match]: ...
    def list_for_opportunity(self, opp_id: OpportunityId) -> list[Match]: ...

class MatchRequestRepository(Protocol):
    def get(self, req_id: MatchRequestId) -> Optional[MatchRequest]: ...
    def add(self, req: MatchRequest) -> None: ...
    def save(self, req: MatchRequest) -> None: ...
    def list_pending_for_opportunity(self, opp_id: OpportunityId) -> list[MatchRequest]: ...

class NotificationRepository(Protocol):
    def get(self, notif_id: NotificationId) -> Optional[Notification]: ...
    def add(self, notif: Notification) -> None: ...
    def save(self, notif: Notification) -> None: ...
    def list_queue(self, *, limit: int = 100) -> list[Notification]: ...

class UserRepository(Protocol):
    def get_by_email(self, email: str) -> Optional[User]: ...
    def get_by_auth0_sub(self, auth0_sub: str) -> Optional[User]: ...
    def add(self, user: User) -> None: ...
    def save(self, user: User) -> None: ...

class VolunteerHistoryRepository(Protocol):
    def get(self, entry_id: VolunteerHistoryEntryId) -> Optional[VolunteerHistoryEntry]: ...
    def add(self, entry: VolunteerHistoryEntry) -> None: ...
    def save(self, entry: VolunteerHistoryEntry) -> None: ...
    def list_for_user(self, user_id: UserId, *, limit: int = 100) -> list[VolunteerHistoryEntry]: ...
    def list_for_event(self, event_id: EventId) -> list[VolunteerHistoryEntry]: ...

# ---- Unit of Work (transactions & repo access) ----

class UnitOfWork(Protocol):
    events: EventRepository
    profiles: ProfileRepository
    opportunities: OpportunityRepository
    matches: MatchRepository
    match_requests: MatchRequestRepository
    notifications: NotificationRepository
    users: UserRepository
    volunteer_history: VolunteerHistoryRepository

    def commit(self) -> None: ...
    def rollback(self) -> None: ...
